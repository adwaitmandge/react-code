{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\Adwait\\\\OneDrive\\\\Desktop\\\\react-advanced-2020\\\\src\\\\tutorial\\\\12-memo-useMemo-useCallback\\\\setup\\\\index.js\";\nimport React, { useState, useEffect, useCallback, useMemo } from \"react\";\nimport { useFetch } from \"../../9-custom-hooks/final/2-useFetch\"; // ATTENTION!!!!!!!!!!\n// I SWITCHED TO PERMANENT DOMAIN\n\nconst url = \"https://course-api.com/javascript-store-products\"; // every time props or state changes, component re-renders\n//Every single time you click the 'count' button, it is going to trigger a re-render because a useState preserves values between re-renders and triggers re-renders and so 'Index' component re-renders and subsequently its children component also re-render i.e 'BigList' and re-rendering of 'BigList' triggers re-rendering of 'Single Product' so basically if there are 12 Products then every time you increase the count, useEffect for Big list gets triggered once and that of Single Product gets triggered 12 times as there are 12 products so it is triggered once per product\n// Solution is using the memo function that comes with React i.e React.memo, not to be confused with useMemo which is a hook, what you basically wanna do is wrap that component that is causing re-rendering of a child component multiple times under React.memo, in our case, it is 'BigList'\n//React.Memo\n\nconst Index = () => {\n  const {\n    products\n  } = useFetch(url);\n  const [count, setCount] = useState(0);\n  const [cart, setCart] = useState(0);\n\n  const addToCart = () => {};\n\n  return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(\"h1\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 26,\n      columnNumber: 7\n    }\n  }, \"Count : \", count), /*#__PURE__*/React.createElement(\"button\", {\n    className: \"btn\",\n    onClick: () => setCount(count + 1),\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 27,\n      columnNumber: 7\n    }\n  }, \"click me\"), /*#__PURE__*/React.createElement(\"h1\", {\n    style: {\n      marginTop: '3rem'\n    },\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 30,\n      columnNumber: 7\n    }\n  }, \"Cart : \", cart), /*#__PURE__*/React.createElement(BigList, {\n    products: products,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 31,\n      columnNumber: 7\n    }\n  }));\n}; //React.memo is going to check the value of the prop passed, in this case -> products, if the value of the prop does then we are not triggering re-render and consequently useEffect() is not triggered as it is called at every re-render\n//We are triggering a re-render everytime you hit the count button\n\n\nconst BigList = React.memo(({\n  products\n}) => {\n  //Memo is basically going to check if the value of the prop i.e. product has changed and if it hasn't changed then no re-renders take place\n  useEffect(() => {\n    console.log(\"Big List\");\n  });\n  return /*#__PURE__*/React.createElement(\"section\", {\n    className: \"products\",\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 46,\n      columnNumber: 5\n    }\n  }, products.map(product => {\n    return /*#__PURE__*/React.createElement(SingleProduct, Object.assign({\n      key: product.id\n    }, product, {\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 48,\n        columnNumber: 16\n      }\n    }));\n  }));\n});\n\nconst SingleProduct = ({\n  fields\n}) => {\n  useEffect(() => {\n    console.count(\"Single Product\");\n  });\n  let {\n    name,\n    price\n  } = fields;\n  price = price / 100;\n  const image = fields.image[0].url;\n  return /*#__PURE__*/React.createElement(\"article\", {\n    className: \"product\",\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 63,\n      columnNumber: 5\n    }\n  }, /*#__PURE__*/React.createElement(\"img\", {\n    src: image,\n    alt: name,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 64,\n      columnNumber: 7\n    }\n  }), /*#__PURE__*/React.createElement(\"h4\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 65,\n      columnNumber: 7\n    }\n  }, name), /*#__PURE__*/React.createElement(\"p\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 66,\n      columnNumber: 7\n    }\n  }, \"$\", price));\n};\n\nexport default Index;","map":{"version":3,"sources":["C:/Users/Adwait/OneDrive/Desktop/react-advanced-2020/src/tutorial/12-memo-useMemo-useCallback/setup/index.js"],"names":["React","useState","useEffect","useCallback","useMemo","useFetch","url","Index","products","count","setCount","cart","setCart","addToCart","marginTop","BigList","memo","console","log","map","product","id","SingleProduct","fields","name","price","image"],"mappings":";AAAA,OAAOA,KAAP,IAAgBC,QAAhB,EAA0BC,SAA1B,EAAqCC,WAArC,EAAkDC,OAAlD,QAAiE,OAAjE;AACA,SAASC,QAAT,QAAyB,uCAAzB,C,CAEA;AACA;;AACA,MAAMC,GAAG,GAAG,kDAAZ,C,CAEA;AAEA;AAEA;AAEA;;AACA,MAAMC,KAAK,GAAG,MAAM;AAClB,QAAM;AAAEC,IAAAA;AAAF,MAAeH,QAAQ,CAACC,GAAD,CAA7B;AACA,QAAM,CAACG,KAAD,EAAQC,QAAR,IAAoBT,QAAQ,CAAC,CAAD,CAAlC;AACA,QAAM,CAACU,IAAD,EAAOC,OAAP,IAAkBX,QAAQ,CAAC,CAAD,CAAhC;;AAEA,QAAMY,SAAS,GAAG,MAAM,CAEvB,CAFD;;AAIA,sBACE,uDACE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,iBAAaJ,KAAb,CADF,eAEE;AAAQ,IAAA,SAAS,EAAC,KAAlB;AAAwB,IAAA,OAAO,EAAE,MAAMC,QAAQ,CAACD,KAAK,GAAG,CAAT,CAA/C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,gBAFF,eAKE;AAAI,IAAA,KAAK,EAAE;AAACK,MAAAA,SAAS,EAAC;AAAX,KAAX;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,gBAAuCH,IAAvC,CALF,eAME,oBAAC,OAAD;AAAS,IAAA,QAAQ,EAAEH,QAAnB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IANF,CADF;AAUD,CAnBD,C,CAqBA;AAEA;;;AACA,MAAMO,OAAO,GAAGf,KAAK,CAACgB,IAAN,CAAW,CAAC;AAAER,EAAAA;AAAF,CAAD,KAAkB;AAC3C;AACAN,EAAAA,SAAS,CAAC,MAAM;AACde,IAAAA,OAAO,CAACC,GAAR,CAAY,UAAZ;AACD,GAFQ,CAAT;AAIA,sBACE;AAAS,IAAA,SAAS,EAAC,UAAnB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,KACGV,QAAQ,CAACW,GAAT,CAAcC,OAAD,IAAa;AACzB,wBAAO,oBAAC,aAAD;AAAe,MAAA,GAAG,EAAEA,OAAO,CAACC;AAA5B,OAAoCD,OAApC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,OAAP;AACD,GAFA,CADH,CADF;AAOD,CAbe,CAAhB;;AAcA,MAAME,aAAa,GAAG,CAAC;AAAEC,EAAAA;AAAF,CAAD,KAAgB;AACpCrB,EAAAA,SAAS,CAAC,MAAM;AACde,IAAAA,OAAO,CAACR,KAAR,CAAc,gBAAd;AACD,GAFQ,CAAT;AAIA,MAAI;AAAEe,IAAAA,IAAF;AAAQC,IAAAA;AAAR,MAAkBF,MAAtB;AACAE,EAAAA,KAAK,GAAGA,KAAK,GAAG,GAAhB;AACA,QAAMC,KAAK,GAAGH,MAAM,CAACG,KAAP,CAAa,CAAb,EAAgBpB,GAA9B;AAEA,sBACE;AAAS,IAAA,SAAS,EAAC,SAAnB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,kBACE;AAAK,IAAA,GAAG,EAAEoB,KAAV;AAAiB,IAAA,GAAG,EAAEF,IAAtB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IADF,eAEE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,KAAKA,IAAL,CAFF,eAGE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,UAAKC,KAAL,CAHF,CADF;AAOD,CAhBD;;AAkBA,eAAelB,KAAf","sourcesContent":["import React, { useState, useEffect, useCallback, useMemo } from \"react\";\r\nimport { useFetch } from \"../../9-custom-hooks/final/2-useFetch\";\r\n\r\n// ATTENTION!!!!!!!!!!\r\n// I SWITCHED TO PERMANENT DOMAIN\r\nconst url = \"https://course-api.com/javascript-store-products\";\r\n\r\n// every time props or state changes, component re-renders\r\n\r\n//Every single time you click the 'count' button, it is going to trigger a re-render because a useState preserves values between re-renders and triggers re-renders and so 'Index' component re-renders and subsequently its children component also re-render i.e 'BigList' and re-rendering of 'BigList' triggers re-rendering of 'Single Product' so basically if there are 12 Products then every time you increase the count, useEffect for Big list gets triggered once and that of Single Product gets triggered 12 times as there are 12 products so it is triggered once per product\r\n\r\n// Solution is using the memo function that comes with React i.e React.memo, not to be confused with useMemo which is a hook, what you basically wanna do is wrap that component that is causing re-rendering of a child component multiple times under React.memo, in our case, it is 'BigList'\r\n\r\n//React.Memo\r\nconst Index = () => {\r\n  const { products } = useFetch(url);\r\n  const [count, setCount] = useState(0);\r\n  const [cart, setCart] = useState(0);\r\n\r\n  const addToCart = () => {\r\n    \r\n  };  \r\n\r\n  return (\r\n    <>\r\n      <h1>Count : {count}</h1>\r\n      <button className=\"btn\" onClick={() => setCount(count + 1)}>\r\n        click me\r\n      </button>\r\n      <h1 style={{marginTop:'3rem'}}>Cart : {cart}</h1>\r\n      <BigList products={products} />\r\n    </>\r\n  );\r\n};\r\n\r\n//React.memo is going to check the value of the prop passed, in this case -> products, if the value of the prop does then we are not triggering re-render and consequently useEffect() is not triggered as it is called at every re-render\r\n\r\n//We are triggering a re-render everytime you hit the count button\r\nconst BigList = React.memo(({ products }) => {\r\n  //Memo is basically going to check if the value of the prop i.e. product has changed and if it hasn't changed then no re-renders take place\r\n  useEffect(() => {\r\n    console.log(\"Big List\");\r\n  });\r\n\r\n  return (\r\n    <section className=\"products\">\r\n      {products.map((product) => {\r\n        return <SingleProduct key={product.id} {...product}></SingleProduct>;\r\n      })}\r\n    </section>\r\n  );\r\n});\r\nconst SingleProduct = ({ fields }) => {\r\n  useEffect(() => {\r\n    console.count(\"Single Product\");\r\n  });\r\n\r\n  let { name, price } = fields;\r\n  price = price / 100;\r\n  const image = fields.image[0].url;\r\n\r\n  return (\r\n    <article className=\"product\">\r\n      <img src={image} alt={name} />\r\n      <h4>{name}</h4>\r\n      <p>${price}</p>\r\n    </article>\r\n  );\r\n};\r\n\r\nexport default Index;\r\n"]},"metadata":{},"sourceType":"module"}