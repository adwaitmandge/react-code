{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\Adwait\\\\OneDrive\\\\Desktop\\\\react-advanced-2020\\\\src\\\\tutorial\\\\2-useEffect\\\\setup\\\\3-useEffect-fetch-data.js\";\nimport React, { useEffect, useState } from \"react\";\nconst url = \"https://api.github.com/users\";\n\nconst UseEffectFetchData = () => {\n  const [users, setUsers] = useState([]);\n\n  const getUsers = async () => {\n    const res = await fetch(url);\n    const users = await res.json();\n    setUsers(users);\n  };\n\n  useEffect(() => {\n    //You cannot make this callback within useEffect an async function\n    //Here an infinite loop will run as during the first render, useEffect will be invoked which further invokes getUsers and getUsers invokes setUsers which will trigger a re-render so useEffect will be triggered again which further invoke getUsers and so on and so on and so on, so the solution to this problem is adding an empty dependency list to useEffect and so useEffect will be triggered only on the first render\n    getUsers();\n  }, []);\n  return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(\"h2\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 23,\n      columnNumber: 7\n    }\n  }, \"github users\"), /*#__PURE__*/React.createElement(\"ul\", {\n    className: \"users\",\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 24,\n      columnNumber: 7\n    }\n  }, users.map(user => {\n    const {\n      login,\n      id,\n      avatar_url,\n      html_url\n    } = user;\n    return /*#__PURE__*/React.createElement(\"li\", {\n      key: id,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 29,\n        columnNumber: 13\n      }\n    }, /*#__PURE__*/React.createElement(\"img\", {\n      src: avatar_url,\n      className: \"image\",\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 30,\n        columnNumber: 15\n      }\n    }), /*#__PURE__*/React.createElement(\"h4\", {\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 31,\n        columnNumber: 15\n      }\n    }, login));\n  })), \";\");\n};\n\nexport default UseEffectFetchData;","map":{"version":3,"sources":["C:/Users/Adwait/OneDrive/Desktop/react-advanced-2020/src/tutorial/2-useEffect/setup/3-useEffect-fetch-data.js"],"names":["React","useEffect","useState","url","UseEffectFetchData","users","setUsers","getUsers","res","fetch","json","map","user","login","id","avatar_url","html_url"],"mappings":";AAAA,OAAOA,KAAP,IAAgBC,SAAhB,EAA2BC,QAA3B,QAA2C,OAA3C;AAEA,MAAMC,GAAG,GAAG,8BAAZ;;AAEA,MAAMC,kBAAkB,GAAG,MAAM;AAC/B,QAAM,CAACC,KAAD,EAAQC,QAAR,IAAoBJ,QAAQ,CAAC,EAAD,CAAlC;;AAEA,QAAMK,QAAQ,GAAG,YAAY;AAC3B,UAAMC,GAAG,GAAG,MAAMC,KAAK,CAACN,GAAD,CAAvB;AACA,UAAME,KAAK,GAAG,MAAMG,GAAG,CAACE,IAAJ,EAApB;AACAJ,IAAAA,QAAQ,CAACD,KAAD,CAAR;AACD,GAJD;;AAMAJ,EAAAA,SAAS,CAAC,MAAM;AACd;AAEA;AACAM,IAAAA,QAAQ;AACT,GALQ,EAKN,EALM,CAAT;AAOA,sBACE,uDACE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,oBADF,eAEE;AAAI,IAAA,SAAS,EAAC,OAAd;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,KACGF,KAAK,CAACM,GAAN,CAAWC,IAAD,IAAU;AACnB,UAAM;AAAEC,MAAAA,KAAF;AAASC,MAAAA,EAAT;AAAaC,MAAAA,UAAb;AAAyBC,MAAAA;AAAzB,QAAsCJ,IAA5C;AAEA,wBACE;AAAI,MAAA,GAAG,EAAEE,EAAT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,oBACE;AAAK,MAAA,GAAG,EAAEC,UAAV;AAAsB,MAAA,SAAS,EAAC,OAAhC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MADF,eAEE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,OAAKF,KAAL,CAFF,CADF;AAOD,GAVA,CADH,CAFF,MADF;AAmBD,CAnCD;;AAqCA,eAAeT,kBAAf","sourcesContent":["import React, { useEffect, useState } from \"react\";\r\n\r\nconst url = \"https://api.github.com/users\";\r\n\r\nconst UseEffectFetchData = () => {\r\n  const [users, setUsers] = useState([]);\r\n\r\n  const getUsers = async () => {\r\n    const res = await fetch(url);\r\n    const users = await res.json();\r\n    setUsers(users);\r\n  };\r\n\r\n  useEffect(() => {\r\n    //You cannot make this callback within useEffect an async function\r\n\r\n    //Here an infinite loop will run as during the first render, useEffect will be invoked which further invokes getUsers and getUsers invokes setUsers which will trigger a re-render so useEffect will be triggered again which further invoke getUsers and so on and so on and so on, so the solution to this problem is adding an empty dependency list to useEffect and so useEffect will be triggered only on the first render\r\n    getUsers();\r\n  }, []);\r\n\r\n  return (\r\n    <>\r\n      <h2>github users</h2>\r\n      <ul className=\"users\">\r\n        {users.map((user) => {\r\n          const { login, id, avatar_url, html_url } = user;\r\n\r\n          return (\r\n            <li key={id}>\r\n              <img src={avatar_url} className=\"image\" />\r\n              <h4>{login}</h4>\r\n              \r\n            </li>\r\n          );\r\n        })}\r\n      </ul>\r\n      ;\r\n    </>\r\n  );\r\n};\r\n\r\nexport default UseEffectFetchData;\r\n"]},"metadata":{},"sourceType":"module"}